/*
  This example program provides a trivial server program that listens for TCP
  connections on port 9995.  When they arrive, it writes a short message to
  each client connection, and closes each connection once it is flushed.

  Where possible, it exits cleanly in response to a SIGINT (ctrl-c).
*/

/*
 * 1. 主线程主要是监听用户的socket连接事件；工作线程主要监听socket的读写事件
 *
 */

#include <string.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#ifndef _WIN32
#include <netinet/in.h>
# ifdef _XOPEN_SOURCE_EXTENDED
#  include <arpa/inet.h>
# endif
#include <sys/socket.h>
#endif

#include <event2/bufferevent.h>
#include <event2/buffer.h>
#include <event2/listener.h>
#include <event2/util.h>
#include <event2/event.h>
#include "event2/thread.h"
#include <event2/event_struct.h>
#include "pthread.h"

#include <sys/time.h>
/** sigaction() */
#include <bits/sigaction.h>
/** assert() */
#include <assert.h>

/** CQ_ITEM queue */
#include <stdlib.h>

static const char MESSAGE[] = "Hello, world! This is libevent. \r\n";

static const int PORT = 9995;

// 线程pool中的子线程总线
#define THREAD_NUM 2	/* 5 */
// 线程均衡调度时记录上一次用过的线程 id
int nLastThreadTid = 0;

#define DATA_BUFFER_SIZE 2048
/** High water marks for buffer shrinking */
#define READ_BUFFER_HIGHWAT 8192

/** Child Thread : Number of worker threads that have finished setting themselves up. */
static int 				init_count = 0;
static pthread_mutex_t	init_lock;
static pthread_cond_t	init_cond;

static void wait_for_thread_registration(int nthreads);
static void register_thread_initialized(void);

/** 自定义 bool 类型  */
typedef enum {
	false,
	true
} bool;

/** Main Thread  */
typedef struct {
	pthread_t tid;
	struct event_base *base;
}TDispatcherThread;
TDispatcherThread stDispatcherThread;

/** 
 * Possible states of a connection.  enum conn_states{} - Copy from memcached-1.5.10 
 */
enum conn_states {
    conn_listening,  /**< the socket which listens for connections */
    conn_new_cmd,    /**< Prepare connection for next command */
    conn_waiting,    /**< waiting for a readable socket */
    conn_read,       /**< reading in a command line */
    conn_parse_cmd,  /**< try to parse a command from the input buffer */
    conn_write,      /**< writing out a simple response */
    conn_nread,      /**< reading in a fixed number of bytes */
    conn_swallow,    /**< swallowing unnecessary bytes w/o storing */
    conn_closing,    /**< closing this connection */
    conn_mwrite,     /**< writing out many items sequentially */
    conn_closed,     /**< connection is closed */
    conn_watch,      /**< held by the logger thread as a watcher */
    conn_max_state   /**< Max state value (used for assertion) */
};

enum protocol {
    ascii_prot = 3, /* arbitrary value. */
    binary_prot,
    negotiating_prot /* Discovering the protocol */
};
	
/** 
 * enum network_transport{} - Copy from memcached-1.5.10 
 */
enum network_transport {
    local_transport, /* Unix sockets*/
    tcp_transport,
    udp_transport
};

/* An item in the connection queue. */
enum conn_queue_item_modes {
    queue_new_conn,   /* brand new connection. */
    queue_redispatch, /* redispatching from side thread */
};

/* An item in the connection queue. */
typedef struct conn_queue_item CQ_ITEM;
struct conn_queue_item {
    int               sfd;   		//socket的fd
    enum conn_states  init_state; 	//事件类型
    int               event_flags; 	//libevent的flags
    int               read_buffer_size; //读取的buffer的size
    enum network_transport     transport; 	
    enum conn_queue_item_modes mode;
    CQ_ITEM          *next; 		//下一个item的地址
};

/* A connection queue. */
typedef struct conn_queue {
    CQ_ITEM *head;
    CQ_ITEM *tail;
    pthread_mutex_t lock;
}CQ;

/** Stats stored per-thread.  */
#define THREAD_STATS_FIELDS \
    X(get_cmds) \
    X(get_misses) \
    X(get_expired) \
    X(get_flushed) \
    X(touch_cmds) \
    X(touch_misses) \
    X(delete_misses) \
    X(incr_misses) \
    X(decr_misses) \
    X(cas_misses) \
    X(bytes_read) \
    X(bytes_written) \
    X(flush_cmds) \
    X(conn_yields) /* # of yields for connections (-R option)*/ \
    X(auth_cmds) \
    X(auth_errors) \
    X(idle_kicks) /* idle connections killed */

struct thread_stats {
    pthread_mutex_t   mutex;	
#define X(name) ev_uint64_t  name;
	THREAD_STATS_FIELDS
#undef X
};

/** 需要保存的信息结构, 用于管道通信和基事件的管理 */
typedef struct {
	pthread_t tid;
	struct event_base *base;
	struct event *notify_event;	/** listen event for notify pipe */
	int read_fd;				/** 管道接收端    */
	int write_fd;				/** 管道发送端    */
	int connect_fd;
	//char *buffer;
	char buffer[128];
    struct thread_stats stats;  /* Stats generated by this thread */
	struct conn_queue *new_conn_queue;	/** 新连接的队列结构 */
}TLibeventThread;
//TLibeventThread *pLibeventThread = (TLibeventThread *)calloc(THREAD_NUM, sizeof(TLibeventThread));
TLibeventThread pLibeventThread[THREAD_NUM];

// 监听回调函数（即一个新链接到来的时候的回调函数）
static void listener_cb(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);
// 主 Loop 超时回调函数
static void timeout_cb(evutil_socket_t fd, short event, void *arg);
// Child thread proces func.
static void thread_libevent_process_cb(evutil_socket_t fd, short event, void *arg);
// 写回调函数
static void conn_writecb(evutil_socket_t fd, short event, void *arg);
// 客户端关闭回调函数
static void conn_eventcb(struct bufferevent *, short, void *);
//信号处理函数
static void signal_cb(evutil_socket_t, short, void *);
// 读回调函数
static void conn_readcb(evutil_socket_t fd, short event, void *arg);
// Init Child Thread(read & write data).
static int create_pthread_pool(void);
// Child Thread func(read & write data).
static void * worker_thread(void *arg);

/** CQ_ITEM queue */
#define ITEMS_PER_ALLOC 64
/* Free list of CQ_ITEM structs */
static CQ_ITEM *cqi_freelist;
static pthread_mutex_t cqi_freelist_lock;
/** CQ_ITEM  queue 的操作接口函数 */
static CQ_ITEM *cqi_new(void);
static void cqi_free(CQ_ITEM *item);
static CQ_ITEM *cq_pop(CQ *cq);
static void cq_init(CQ *cq);
static void cq_push(CQ *cq, CQ_ITEM *item);

/** The structure representing a connection into memcached. */
struct conn {	
    int    sfd;	
    enum conn_states  state;
	struct event *ev;
    short  ev_flags;	
    short  which;	/** which events were just triggered */

	
    char   *rbuf;   /** buffer to read commands into, --- 用于存储客户端数据报文中的命令 */
    char   *rcurr;  /** but if we parsed some already, this is where we stopped --- 未解析的命令的字符指针 */
    int    rsize;   /** total allocated size of rbuf , --- rbuf的大小 */
    int    rbytes;  /** how much data, starting from rcur, do we have unparsed --- 未解析的命令的长度 */

    char   *wbuf;
    char   *wcurr;
	int    wsize;
	int    wbytes;
	
    /** which state to go into after finishing current write */
    enum conn_states  write_and_go;

	/** rlbytes字段表示要读的“value数据”还剩下多少字节 （注意与"rbytes"的区别） */	
    int    rlbytes;

	/** IEC-104 Private Var */
	char 	m_bHaveNew;			/** == 1 : Had receive one completed Msg  */
	char	*m_pBuff;			/** 存储接收到的当前报文帧, 是已经解析后的字节,  在 conn_new() 内初始化				 */
	int		m_nRxCount; 		/** 已经正确接收到的当前报文帧 	的字节数	*/
	int		m_nRxLen;			/** 对应报文中的 length  	 */
	
	
    enum protocol protocol;		/* which protocol this connection speaks */
	enum network_transport transport;	/* what transport is used by this connection */
	struct conn   	*next;	  	/* Used for generating a list of conn structures */
	TLibeventThread *thread;	/* Pointer to the thread object serving this connection */
};

/** variables */
static int max_fds;
struct conn **conns;

static void conn_init(void);
struct conn *conn_new(const int sfd, const enum conn_states init_state, const int event_flags, const int read_buffer_size, enum network_transport transport, struct event_base *base);
static void conn_set_state(struct conn *c, enum conn_states state);
static void conn_shrink(struct conn *c);


/** state-machine func. */
static void drive_machine(struct conn *c);
static void reset_cmd_handler(struct conn *c);

enum try_read_result {
    READ_DATA_RECEIVED,
    READ_NO_DATA_RECEIVED,
    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */
    READ_MEMORY_ERROR      /** failed to allocate more memory */
};
static enum try_read_result try_read_network(struct conn *c);
static int try_read_command(struct conn *c);


/** child-thread 处理事务 */
static bool update_event(struct conn *c, const int new_flags);
void event_handler(const int fd, const short which, void *arg);

/** 使 main-thread  &  child-thread 都能忽略掉 SIGPIPE 信号 */
static int sigignore(int sig) 
{
    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };
	sigset_t signal_mask;

    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {
        return -1;
    }

	/** @2018-08-19   但是POSIX的线程，对信号的捕获是逐条线程进行的，所以引出了下面的解决方案 */
	sigemptyset(&signal_mask);
	sigaddset(&signal_mask, SIGPIPE);
	if(pthread_sigmask(SIG_BLOCK, &signal_mask, NULL) == -1){
		return -1;
	}

    return 0;
}

int
main(int argc, char **argv)
{	
	int i = 0;			// for 循环的迭代次数			
	int nRet = 0; 		// return Value, if !=0 means error.	
	int fd[2] = {0};	// read, write 描述符
	// event_base对象（即Reactor实例）
	struct event_base *base;
	struct evconnlistener *listener;
	// 信号事件处理器,      主loop 超时timer, 
	struct event *signal_event;
	struct event *timeout;
	// 超时 timer 定时值
	struct timeval tv;

	// 地址
	struct sockaddr_in sin;
	
	// 如果是windows环境，再调用socket相关函数之前需要进行动态库初始化
#ifdef _WIN32
	WSADATA wsa_data;
	WSAStartup(0x0201, &wsa_data);
#endif

	/** Use Muti-thread */
	evthread_use_pthreads();
	stDispatcherThread.tid = pthread_self();
	printf("stDispatcherThread.tid : %lld \r\n", stDispatcherThread.tid);

	// 创建一个event_base实例（即一个Reactor实例）
	base = event_base_new();
	if (!base) {
		fprintf(stderr, "Could not initialize libevent!\n");
		return 1;
	}
	/** Clear 0, and Init  */
	memset(&stDispatcherThread, 0, sizeof(TDispatcherThread));
	stDispatcherThread.base = base;

    /** initialize other stuff */
	conn_init();

    /*
     * ignore SIGPIPE signals; we can use errno == EPIPE if we
     * need that information
     * @2018-08-19 
     * 1. 对于一个对端关闭的 socket 进行 2 次写操作,  第 2 次会产生一个 SIGPIPE 信号, 该信号默认
     *   退出进程. 
     */
	if (sigignore(SIGPIPE) == -1){
		printf("main() : Failed to ignore SIGPIPE; sigignore \r\n");
		return (-1);
	}

	/** Init Child thread. */	
    pthread_mutex_init(&init_lock, NULL);
    pthread_cond_init(&init_cond, NULL);

	pthread_mutex_init(&cqi_freelist_lock, NULL);
	cqi_freelist = NULL;
	
	for(i=0; i<THREAD_NUM; i++)
	{
		nRet = evutil_socketpair(AF_UNIX, SOCK_STREAM, 0, fd);
		if(-1 == nRet)
		{
			printf("evutil_socketpair() error.  \r\n");
			return nRet;
		}
		pLibeventThread[i].read_fd  = fd[0];
		pLibeventThread[i].write_fd = fd[1];
		pLibeventThread[i].base		= event_base_new();
		if (NULL == pLibeventThread[i].base) 
		{
			printf("Could not initialize libevent for pLibeventThread. \r\n");
			return -1;
		}
		
		/** Set up a thread's information. */
		pLibeventThread[i].notify_event = event_new(pLibeventThread[i].base, pLibeventThread[i].read_fd, EV_READ| EV_PERSIST, 
			thread_libevent_process_cb, &pLibeventThread[i]);

		// 将事件处理器添加到event_base的事件处理器注册队列中.		
		if(!(pLibeventThread[i].notify_event) || event_add(pLibeventThread[i].notify_event, 0)<-1)
		{
			printf("event_add() error : pLibeventThread[i].ev.\r\n");
			return -1;
		}

		pLibeventThread[i].new_conn_queue = malloc(sizeof(struct conn_queue));
		if (NULL == pLibeventThread[i].new_conn_queue)
		{
			printf("Failed to allocate memory for connection queue. \r\n");
			return -1;
		}
		cq_init(pLibeventThread[i].new_conn_queue);

		if(pthread_mutex_init(&pLibeventThread[i].stats.mutex, NULL) != 0) 
		{
			printf("Failed to initialize mutex. \r\n");
			return -1;
		}
		
	}
	
    /** Create threads after we've done all the libevent setup. */
	if(create_pthread_pool() < 0)
	{
		printf("create_pthread_pool() error. \r\n");
		return -1;
	}
	
    /** 
     * 1. Wait for all the threads to set themselves up before returning.  
     * 2. mutex_lock(&init_lock) 主要是用来保护 pthread_cond_wait 等待临界时期的情况 
     */
	pthread_mutex_lock(&init_lock);
	wait_for_thread_registration(THREAD_NUM);
	pthread_mutex_unlock(&init_lock);	

	/** 
	  * Mian-Loop timer 
	  * 1. EV_PERSIST 可以用于标识一个 持续 的超时事件,  而 evtimer_new() 只是用于单次触发的事件, 则需要
	  *   每次在 timeout_cb() 中重新设置 & ADD 超时 timer 值
	  * 2. 2018-08-15 event_new() 中可以设置 EV_PERSIST 标识则用于 周期触发 timeout_cb, 且
	  *   无需在 timeout_cb ADD tiemr 值
	  */	
	timeout = event_new(stDispatcherThread.base, -1, EV_PERSIST, timeout_cb, timeout);
	//timeout = evtimer_new(stDispatcherThread.base, timeout_cb, timeout);
	//evutil_timerclear(&tv);	// 暂时屏蔽否则找不到 <sys/time.h> 文件中的函数声明
	tv.tv_sec = tv.tv_usec = 0;
	tv.tv_sec = 5;	
	//  timeout处 理器添加到event_base的事件处理器注册队列中.
	if (!timeout || event_add(timeout, &tv)<0) {
		printf("event_add() error : timeout.\r\n");
		return -1;
	}
	
	/** before using sockaddr_in,  need Clear  it */
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_port = htons(PORT);

	// 第 1 个实参表示 : 所属的event_base对象; 第 4 个实参是标志 : 地址可复用，调用exec的时候关闭套接字
	// s1. 注册当发生某一操作(比如接受来自客户端的连接)时应该执行的函数.
	listener = evconnlistener_new_bind(stDispatcherThread.base, listener_cb, (void *)stDispatcherThread.base,
	    LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1,
	    (struct sockaddr*)&sin,
	    sizeof(sin));

	if (!listener) {
		fprintf(stderr, "Could not create a listener!\n");
		return 1;
	}

	/** 2018-08-14  signal_cb , there is no use in code , and reserved. */
	signal_event = evsignal_new(stDispatcherThread.base, SIGINT, signal_cb, (void *)stDispatcherThread.base);

	// 将事件处理器添加到event_base的事件处理器注册队列中.
	if (!signal_event || event_add(signal_event, NULL)<0) {
		fprintf(stderr, "Could not create/add a signal event!\n");
		return -1;
	}

	// s2. 主事件循环, 进入循环.
	event_base_dispatch(stDispatcherThread.base);

    // s.Final.  释放监听器, 一般情况, 只要 event_base_loop 在循环中, 则不会执行到下面的函数; 除非程序结束
	evconnlistener_free(listener);

	// 释放事件处理器
	event_free(signal_event);
	event_free(timeout);

	// 释放 event_base 对象,  Child-Thread.base 的销毁留在了 Child-Thread 的 worker func. 中.
	event_base_free(stDispatcherThread.base);
	//for(i=0; i<THREAD_NUM; i++){
	//	event_base_free(pLibeventThread[i].base);
	//}

	printf("done\n");
	return 0;
}


/**
 * listener_cb(...)  
 * Dispatches a new connection to another thread. This is only ever called
 * from the main thread, either during initialization (for UDP) or because
 * of an incoming connection.
 * 2018-08-27 Reference code -- dispatch_conn_new()
 */
static void
listener_cb(struct evconnlistener *listener, evutil_socket_t fd,
    struct sockaddr *sa, int socklen, void *user_data)
{
	struct event_base *base = user_data;
	// 缓冲区
	struct bufferevent *bev;

	// Test : print Client IP & port
	struct sockaddr_in sin;
	unsigned char *pcAddr;
	
    //每个连接连上来的时候, 都会申请一块CQ_ITEM的内存块, 用于存储连接的基本信息
    CQ_ITEM *pItem = cqi_new();

	/** 线程分发 */		
	/** memcached中线程负载均衡算法 (求余法) - 有待分析 by tian           */
	int nTid = (nLastThreadTid + 1) % THREAD_NUM;
	TLibeventThread *thread = pLibeventThread + nTid;
	nLastThreadTid = nTid;

	thread->connect_fd = fd;

	pItem->sfd = fd;
	pItem->init_state = conn_new_cmd;
	pItem->event_flags = EV_READ|EV_PERSIST;
	pItem->read_buffer_size = DATA_BUFFER_SIZE;
	pItem->transport = tcp_transport;
	pItem->mode = queue_new_conn;
	
	//向工作线程的队列中放入CQ_ITEM	
    cq_push(thread->new_conn_queue, pItem);

	// 线程读写 child-thread,  先 write 1 个无实际意义字节c, 可以触发该 child-thread 的 thread_libevent_process_cb()
	write(thread->write_fd, "c", 1);	
	
#if 0	
    // 1. 基于套接字创建一个缓冲区（套接字接收到数据之后存放在缓冲区中,套接字在发送数据之前先将数据存放在缓冲区中）
    // 2. 文件描述符 fd 对应最新的 connected 到服务器上的 socket fd.
	bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE|BEV_OPT_THREADSAFE);
	if (!bev) {
		fprintf(stderr, "Error constructing bufferevent!");
		event_base_loopbreak(base);
		return;
	}

	/** Set timeout */
	struct timeval tv_read = {10, 0}, tv_write = {10, 0};
	bufferevent_set_timeouts(bev, &tv_read, &tv_write);
	// Enbale Muti-thread
	if(bufferevent_enable(bev, BEV_OPT_THREADSAFE) < 0)
	{
		printf("bufferevent_enable : BEV_OPT_THREADSAFE, failed. \r\n");
	}	

	/** use user_data for on-shared communicate , and when to be free ?  */
	char *userData = NULL;
	bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, userData);

	// 禁用缓存区的写功能
	//bufferevent_disable(bev, EV_WRITE);
	//bufferevent_enable(bev, EV_WRITE);

	// 启用缓冲区的读      & 写功能
	bufferevent_enable(bev, EV_READ);
	bufferevent_enable(bev, EV_WRITE);

	// 缓冲区写
	//bufferevent_write(bev, MESSAGE, strlen(MESSAGE));
#endif //#if 0

	// test by tian , print the ADDR of Client.
	memcpy(&sin, sa, sizeof(struct sockaddr_in));
	pcAddr = (unsigned char *)&(sin.sin_addr.s_addr);	
	printf("The client ip is : %u.%u.%u.%u.  port is : %d   fd is : %d \r\n", 
		pcAddr[0], pcAddr[1], pcAddr[2], pcAddr[3], sin.sin_port, fd);
}

static void
conn_writecb(evutil_socket_t fd, short event, void *arg)
{
	//printf("conn_writecb() : enter \r\n");
	TLibeventThread *ev_thread = (TLibeventThread*)arg;

	if(NULL == arg){
		printf("conn_writecb() :  NULL == arg \r\n");
		return;
	}

	write(fd, ev_thread->buffer, 128);
	//ev_thread->buffer = NULL;
	memset(ev_thread->buffer, 0, 128);
		
	//printf("conn_writecb() : ok \r\n");
}

static void
conn_eventcb(struct bufferevent *bev, short events, void *user_data)
{
	printf("conn_eventcb() : enter\r\n");
	if (events & BEV_EVENT_EOF) {
		// 客户端关闭
		printf("Connection closed.\n");
	} else if (events & BEV_EVENT_ERROR) {
		// 在连接上产生一个错误
		printf("Got an error on the connection: %s\n",
		    strerror(errno));/*XXX win32*/
	} else if(events & BEV_EVENT_TIMEOUT)	{
		// timeout : reading or writing
		printf("User-specified timeout reached. \r\n");
	}

	bufferevent_free(bev);
	printf("conn_eventcb() : ok \r\n");
}

static void
signal_cb(evutil_socket_t sig, short events, void *user_data)
{
	struct event_base *base = user_data;
	struct timeval delay = { 2, 0 };

	printf("Caught an interrupt signal; exiting cleanly in two seconds.\n");

	// 退出事件循环
	event_base_loopexit(base, &delay);
}

static void
conn_readcb(evutil_socket_t fd, short event, void *arg)
{
	//printf("conn_readcb() : enter \r\n");

	char cBuf[128] = {0};
	int len = 0;	
	struct event *evSend;

	if(NULL == arg){
		printf("conn_readcb() :  NULL == arg \r\n");
		return;
	}

	TLibeventThread *ev_thread =(TLibeventThread*)arg;
	len = read(fd, cBuf, 128);
	if(0 == len){
		// means the socket fd has been Closed.
		printf("socket %d has been Closed. \r\n", fd);
		close(fd);
		return;
	}

	//ev_thread->buffer = cBuf;
	memcpy(ev_thread->buffer, cBuf, 128);
	printf("Thread %llu has read : %s \r\n", ev_thread->tid, ev_thread->buffer);
	
	evSend = event_new(ev_thread->base, ev_thread->connect_fd, EV_WRITE|EV_PERSIST, conn_writecb, ev_thread);
	// 将事件处理器添加到 这个 thread -base  事件处理器注册队列中.	
	if(!evSend || event_add(evSend, 0)<-1)
	{
		printf("event_add() error : evSend \r\n");
		return;
	}	

	//printf("conn_readcb() : ok \r\n");	
	return;
}

static int create_pthread_pool(void)
{
	int nRet = 0 , i = 0;
	for(i=0; i<THREAD_NUM; i++)
	{
		nRet = pthread_create(&pLibeventThread[i].tid, NULL, worker_thread, &pLibeventThread[i]);
		if(0 != nRet)
		{
			printf("create_pthread_pool %d error. \r\n", nRet);
			return -1;
		}
	}
	printf("create_pthread_pool : ok \r\n");
	return 1;
}

static void * worker_thread(void *arg)
{	
    /* Any per-thread setup can happen here; main_thread_init  will block until
     * all threads have finished initializing.
     */
	printf("worker_thread() : enter \r\n");
	TLibeventThread *self = (TLibeventThread *)arg;
	//self->tid = pthread_self();
	
    register_thread_initialized();

	// 每个工作线程都在检测event链表是否有事件发生
	event_base_dispatch(self->base);

	// 销毁 Child-Thread.base
	event_base_free(self->base);

	// 2018-08-15 On normally, Code will not run at the following line, otherwise the Thread error.
	printf("worker_thread() : ok \r\n");
	return NULL;
}

static void timeout_cb(evutil_socket_t fd, short event, void *arg)
{
	//printf("timeout_cb() : enter \r\n");
#if 0	
	struct event *timeout = (struct event *)arg;

	/** memcached中线程负载均衡算法 - 有待分析 by tian           */
	int nTid = (nLastThreadTid + 1) % THREAD_NUM;
	TLibeventThread *thread = pLibeventThread + nTid;
	nLastThreadTid = nTid;

	/**
	  * 线程读写
	  * 1. child-thread used for "Parser Data"
	  */
	write(thread->write_fd, "Hello world. It is timeout_cb()", sizeof("Hello world. It is timeout_cb()") - 1);	
#endif //#if 0
	//printf("timeout_cb() : ok \r\n");
}

static void thread_libevent_process_cb(evutil_socket_t fd, short event, void *arg)
{
	printf("thread_libevent_process_cb() : enter \r\n");

	TLibeventThread *self = (TLibeventThread *)arg;	
	CQ_ITEM *pItem;	
	char cBuf[1] = {0};	
    struct conn *c;
	int nRecv = 0;
	struct event *evRecv;	
    unsigned int timeout_fd;

	if(fd != self->read_fd)
	{
		printf("thread_libevent_process_cb error : fd != self->read_fd \r\n");
		return;
	}

	// 响应pipe可读事件，读取主线程向管道内写的1字节数据(见dispatch_conn_new()函数)
	nRecv = read(fd, cBuf, 1);
	if(nRecv != 1)
	{
		return;
	}	

	switch (cBuf[0]){
		case 'c':{			
			printf("thread %llu receive message : %c \r\n", (pthread_t)self->tid, cBuf[0]);
			pItem = cq_pop(self->new_conn_queue);
			if(NULL == pItem) 
			{
				break;
			}
			
			switch (pItem->mode){
				case queue_new_conn:{
					c = conn_new(pItem->sfd, pItem->init_state, pItem->event_flags,
									pItem->read_buffer_size, pItem->transport,
									self->base);
					if(NULL == c) {
						printf("thread_libevent_process_cb() : NULL == c \r\n");
						close(pItem->sfd);
					} else {
						c->thread = self;
					}					
					break;
				}
				case queue_redispatch:{
					//conn_worker_readd(pItem->c);
					break;
				}
			}
			cqi_free(pItem);
			break;
		}		
		/* a client socket timed out */
		case 't':{
			// Read	 ---  timeout_fd
			break;
		}			
	}
#if 0
	evRecv = event_new(self->base, self->connect_fd, EV_READ|EV_PERSIST, conn_readcb, self);	
	// 将事件处理器添加到 这个 thread -base  事件处理器注册队列中.	
	if(!evRecv || event_add(evRecv, 0)<-1)
	{
		printf("event_add() error : evRecv \r\n");
		return;
	}
#endif //#if 0
	printf("thread_libevent_process_cb() : ok \r\n");
	return;	
}

/*
 * Returns a fresh connection queue item.
 */
static CQ_ITEM *cqi_new(void) {
    CQ_ITEM *item = NULL;
    pthread_mutex_lock(&cqi_freelist_lock);
    if (cqi_freelist) {
        item = cqi_freelist;
        cqi_freelist = item->next;
    }
    pthread_mutex_unlock(&cqi_freelist_lock);

    if (NULL == item) {
        int i;

        /* Allocate a bunch of items at once to reduce fragmentation */
        item = malloc(sizeof(CQ_ITEM) * ITEMS_PER_ALLOC);
        if (NULL == item) {
            //STATS_LOCK();
            //stats.malloc_fails++;
            //STATS_UNLOCK();
            return NULL;
        }

        /*
         * Link together all the new items except the first one
         * (which we'll return to the caller) for placement on
         * the freelist.
         */
        for (i = 2; i < ITEMS_PER_ALLOC; i++)
            item[i - 1].next = &item[i];

        pthread_mutex_lock(&cqi_freelist_lock);
        item[ITEMS_PER_ALLOC - 1].next = cqi_freelist;
        cqi_freelist = &item[1];
        pthread_mutex_unlock(&cqi_freelist_lock);
    }

    return item;
}

/*
 * Frees a connection queue item (adds it to the freelist.)
 */
static void cqi_free(CQ_ITEM *item) {
    pthread_mutex_lock(&cqi_freelist_lock);
    item->next = cqi_freelist;
    cqi_freelist = item;
    pthread_mutex_unlock(&cqi_freelist_lock);
}

/*
 * Looks for an item on a connection queue, but doesn't block if there isn't
 * one.
 * Returns the item, or NULL if no item is available
 */
static CQ_ITEM *cq_pop(CQ *cq) {
    CQ_ITEM *item;

    pthread_mutex_lock(&cq->lock);
    item = cq->head;
    if (NULL != item) {
        cq->head = item->next;
        if (NULL == cq->head)
            cq->tail = NULL;
    }
    pthread_mutex_unlock(&cq->lock);

    return item;
}

/*
 * Adds an item to a connection queue.
 */
static void cq_push(CQ *cq, CQ_ITEM *item) {
    item->next = NULL;

    pthread_mutex_lock(&cq->lock);
    if (NULL == cq->tail)
        cq->head = item;
    else
        cq->tail->next = item;
    cq->tail = item;
    pthread_mutex_unlock(&cq->lock);
}

/*
 * Initializes the connections array. We don't actually allocate connection
 * structures until they're needed, so as to avoid wasting memory when the
 * maximum connection count is much higher than the actual number of
 * connections.
 *
 * This does end up wasting a few pointers' worth of memory for FDs that are
 * used for things other than connections, but that's worth it in exchange for
 * being able to directly index the conns array by FD.
 */
static void conn_init(void) 
{
	max_fds = 0xFF;	// 2018-08-20  需要修改 max_fds     ！！！

	if((conns = calloc(max_fds, sizeof(struct conn*))) == NULL)
	{
		printf("Failed to allocate connection structures \r\n");
		exit(1);
	}	
}

/***/
struct conn *conn_new(const int sfd, enum conn_states init_state,
                const int event_flags,
                const int read_buffer_size, enum network_transport transport,
                struct event_base *base) 
{
	struct conn *c;

	assert(sfd >= 0 && sfd < max_fds);
	c = conns[sfd];

	if(NULL == c)
	{
		if(!(c = (struct conn *)calloc(1, sizeof(struct conn)))){
			printf("Failed to allocate conn object. \r\n");
			return NULL;
		}
		
		/** the following... Conn Create */
		c->rbuf = c->wbuf = 0;		
        c->rsize = read_buffer_size;
		c->wsize = DATA_BUFFER_SIZE;
		c->m_pBuff = 0;

		c->m_pBuff = (char *)malloc((size_t)c->rsize);
		c->rbuf = (char *)malloc((size_t)c->rsize);
        c->wbuf = (char *)malloc((size_t)c->wsize);		
		if(c->rbuf == 0 || c->wbuf == 0){
			return NULL;
		}
		
		c->sfd = sfd;
		conns[sfd] = c;
	}
	
	c->transport = transport;
	//c->protocol;
	c->state = init_state;	
    c->rbytes = c->wbytes = 0;
		
	//主线程主要是监听用户的socket连接事件；工作线程主要监听socket的读写事件  
	//当用户socket的连接有数据传递过来的时候，就会调用event_handler这个回调函数
	c->ev = event_new(base, sfd, event_flags, event_handler, (void *)c);
	// 将事件处理器添加到 这个 thread -base  事件处理器注册队列中.	
	if(!c->ev || event_add(c->ev, 0)<-1)
	{
		printf("event_add() error : &(c->event) \r\n");
		return NULL;
	}
	c->ev_flags = event_flags;

	return c;	
}

/*
 * Sets a connection's current state in the state machine. Any special
 * processing that needs to happen on certain state transitions can
 * happen here.
 */
static void conn_set_state(struct conn *c, enum conn_states state)
{
	assert(c != NULL);
	assert(state >= conn_listening && state < conn_max_state);

	if (state != c->state) {
//		if (settings.verbose > 2) {
//			fprintf(stderr, "%d: going from %s to %s\n",
//					c->sfd, state_text(c->state),
//					state_text(state));
//		}

		if (state == conn_write || state == conn_mwrite) {
//			MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);
		}
		c->state = state;
	}
}

/**
 *
 */
static void conn_close(struct conn *c) {
    assert(c != NULL);

    /* delete the event, the socket and the conn */
    event_del(c->ev); //(&c->event);

    printf("conn_close() : %d connection closed. \r\n", c->sfd);

    //conn_cleanup(c);

    //MEMCACHED_CONN_RELEASE(c->sfd);
    conn_set_state(c, conn_closed);
    close(c->sfd);

    //pthread_mutex_lock(&conn_lock);
    //allow_new_conns = true;
    //pthread_mutex_unlock(&conn_lock);

    return;
}

/*
 * Shrinks a connection's buffers if they're too big.  This prevents
 * periodic large "get" requests from permanently chewing lots of server
 * memory.
 *
 * This should only be called in between requests since it can wipe output
 * buffers!
 */
static void conn_shrink(struct conn *c)
{
    assert(c != NULL);

	/** 
	 * 1. 检查缓冲区 c->rbuf 是否数据满, 
	 */
    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {
        char *newbuf;

        if (c->rcurr != c->rbuf)
            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);

		/** 恢复 c->rbuf 大小为 DATA_BUFFER_SIZE */
        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);

        if (newbuf) {
            c->rbuf = newbuf;
            c->rsize = DATA_BUFFER_SIZE;
        }
        /* TODO check other branch... */
        c->rcurr = c->rbuf;
    }
}

/** Initializes a connection queue. */
static void cq_init(CQ *cq) {
	pthread_mutex_init(&cq->lock, NULL);
	cq->head = NULL;
	cq->tail = NULL;
}

/** 2018-08-27 需要再检查下面的这个函数执行时 registration 线程的个数！！ */
static void wait_for_thread_registration(int nthreads)
{
	static unsigned int nTmpReg = 0;

	nthreads;
	
    while (init_count < THREAD_NUM) {
		/** 2018-08-28 主线程在等待 '条件变量 init_cond'  时仍需要用变量 '已经完成初始化的线程个数   init_count  ' 来作为辅助判断	 			     */
        pthread_cond_wait(&init_cond, &init_lock);
		nTmpReg++;
		printf("wait_for_thread_registration() : %d \r\n", nTmpReg);
		/** 结束此函数的时 nTmpReg 的值的可能范围是  			[0 ~ THREAD_NUM]	*/
    }
}

/** Child-Thread init - register */
static void register_thread_initialized(void) 
{
    pthread_mutex_lock(&init_lock);
    init_count++;
	printf("register_thread_initialized() : %d \r\n", init_count);
    pthread_cond_signal(&init_cond);
    pthread_mutex_unlock(&init_lock);
    /* Force worker threads to pile up if someone wants us to */
    //pthread_mutex_lock(&worker_hang_lock);
    //pthread_mutex_unlock(&worker_hang_lock);
}

/** Child-Thread 处理事务  */
void event_handler(const int fd, const short which, void *arg)
{
	//printf("event_handler() %d -- enter \r\n", fd);
	struct conn *c;

	c = (struct conn *)arg;
	assert(c != NULL);

	c->which = which;
	
    /* sanity */
	if(fd != c->sfd){
		printf("Catastrophic: event fd doesn't match conn fd!\n");
		conn_close(c);
		return;
	}
	
	drive_machine(c);

    /* wait for next event */
	//printf("event_handler() %d -- ok \r\n", fd);
    return;
}

/** Child-Thread 处理事务 - read -to - write */
static bool update_event(struct conn *c, const int new_flags) {
    assert(c != NULL);

    struct event_base *base = (c->ev)->ev_base;

    if (c->ev_flags == new_flags)
        return true;
    if (event_del(c->ev) == -1) return false;
    event_set(c->ev, c->sfd, new_flags, event_handler, (void *)c);
    event_base_set(base, c->ev);
    c->ev_flags = new_flags;
    if (event_add(c->ev, 0) == -1) return false;
    return true;
}

/**/
static void drive_machine(struct conn *c)
{
	bool stop = false;
	int sfd;
	socklen_t addrlen;
	int nRes;

	assert(NULL != c);

	while(!stop){
		//stop = true;

		switch (c->state){
			case conn_listening:{
				/** 正在连接, 还没有 accept */
				break;
			}			
			case conn_waiting:{				
				/** 2018-08-26 等待新的命令请求, 此状态下的操作只是将 conn 状态转换为 conn_read 循环退出				*/
				printf("drive_machine() : case conn_waiting \r\n");
				if(!update_event(c, EV_READ | EV_PERSIST)){                        
                    conn_set_state(c, conn_closing);
                    break;
				}
				conn_set_state(c, conn_read);
				stop = true;
				break;
			}
			case conn_read:{
				printf("drive_machine() : case conn_read \r\n");
				nRes = try_read_network(c);

				switch (nRes) {
					case READ_NO_DATA_RECEIVED:
						conn_set_state(c, conn_waiting);
						break;
					case READ_DATA_RECEIVED:
						/**
						 * 2018-08-26 如果读取数据成功, 则 conn 状态被转换为 conn_parse_cmd....
						 * 2018-08-28 try_read_network(c) 并不确保每次到达     的数据都足够一个完整的 cmd 
						 * 	所以会在接下来的 try_read_command()    	  判断是否是一个完整的 cmd
						 */
						conn_set_state(c, conn_parse_cmd);
						break;
					case READ_ERROR:
						conn_set_state(c, conn_closing);
						break;
					case READ_MEMORY_ERROR:
						/* Failed to allocate more memory */
						/* State already set by try_read_network */
						break;
					}				
				break;
			}
			case conn_parse_cmd : {
				printf("drive_machine() : case conn_parse_cmd \r\n");
				if(try_read_command(c) == 0)
				{
					/** need more data : 当读到的数据还不够成为一个 cmd 的时候则需要 more data ( 这里我们可以把一个完整的 cmd 认为是一帧报文 ) */
					conn_set_state(c, conn_waiting);
				}
				break;
			}
			case conn_new_cmd:{				
				/* Only process nreqs at a time to avoid starving other connections */
				/** 2018-08-26 状态 conn_new_cmd 下的操作只是只是将 conn 的状态转换为 conn_waiting */
				reset_cmd_handler(c);				
#if 0						  
				/** */		  
				if(c->rbytes > 0){
                    /* We have already read in data into the input buffer,
                       so libevent will most likely not signal read events
                       on the socket (unless more data is available. As a
                       hack we should just put in a request to write data,
                       because that should be possible ;-)
                    */
                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {                        
                        conn_set_state(c, conn_closing);
                        break;
                    }
                }
#endif //#if 0				
				stop = true;
				break;
			}
			case conn_nread:{
				if(0 == c->rlbytes){
					//complete_nread(c);	
					break;
				}
				
				/* Check if rbytes < 0, to prevent crash */
				if(c->rlbytes < 0){
					conn_set_state(c, conn_closing);
					break;
				}

				/***/
				
				break;
			}
			case conn_closing:{
				conn_close(c);
				break;
			}				
			default:{	
				break;
			}
		}
	}
	
}

static void reset_cmd_handler(struct conn *c)
{
    conn_shrink(c);
	if(c->rbytes > 0) {
		conn_set_state(c, conn_parse_cmd);	/** 2018-08-27  还有剩余的报文没有处理完, 需要继续处理 parser_cmd...  */
	} else {
		conn_set_state(c, conn_waiting);	/** 无剩余的报文需要处理, 可以等待新的事件到来				 */		
	}		
}

/*
 * read from network as much as we can, handle buffer overflow and connection
 * close.
 * before reading, move the remaining incomplete fragment of a command
 * (if any) to the beginning of the buffer.
 *
 * To protect us from someone flooding a connection with bogus data causing
 * the connection to eat up all available memory, break out and start looking
 * at the data I've got after a number of reallocs...
 *
 * @return enum try_read_result
 */
static enum try_read_result try_read_network(struct conn *c)
{	
    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
	int res;
	int num_allocs = 0;

	assert(c != NULL);

	if(c->rcurr != c->rbuf){
		if(c->rbytes != 0){ /* otherwise there's nothing to copy */
			memmove(c->rbuf, c->rcurr, c->rbytes);
		}
		c->rcurr = c->rbuf;
	}

	while(1){
		if(c->rbytes >= c->rsize){
			if(num_allocs == 4){
				/** 2018-08-27  total size = 2048 *4  */
				return gotdata;
			}			
			++num_allocs;

			char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
			if(!new_rbuf) {
				c->rbytes = 0;	/* ignore what we read */
				printf("SERVER_ERROR out of memory reading request");
				c->write_and_go = conn_closing;
				return READ_MEMORY_ERROR;
			}
			c->rcurr = c->rbuf = new_rbuf;
			c->rsize *= 2;
		}

		int avail = c->rsize - c->rbytes;
		res = read(c->sfd, c->rbuf + c->rbytes, avail );	
		if(res > 0){
			char *tmp = (char*)malloc(sizeof(char)*res);
			memmove(tmp, c->rbuf + c->rbytes, res);
			printf("try_read_network() : Recv Msg -- ");
			for (int i = 0; i < res; ++i)
			{
				printf("%02x ", tmp[i]);
			}
			printf("\r\n");
			free(tmp);
			tmp = NULL;
			pthread_mutex_lock(&c->thread->stats.mutex);
			c->thread->stats.bytes_read += res;
			pthread_mutex_unlock(&c->thread->stats.mutex);
			gotdata = READ_DATA_RECEIVED;
			c->rbytes += res;
			if(res == avail ){
				continue;
			} else {
				break;	/** when res<avail , means have finished read all data */
			}			
		}
		if(0 == res){
			return READ_ERROR;
		}// if(0...)
		if(-1 == res){
			if(EAGAIN == errno || EWOULDBLOCK == errno){
				break;
			}
			return READ_ERROR;
		}// if(-1...)
	}
	return gotdata;
}

/*
 * if we have a complete line in the buffer, process it.
 * 
 */
static int try_read_command(struct conn *c)
{
	assert(c != NULL);
	assert(c->rcurr <= (c->rbuf + c->rsize)); // 2018-08-26 其中 ‘=’ 是否必要？
	assert(c->rbytes > 0);

	/** OnReceive() */
	if(!c->m_bHaveNew) //(!HasNewPackage()) // 在有一帧完整报文的情况下, 不进行处理
	{
		unsigned char *pEnd = c->rcurr + c->rbytes;
		for(; c->rcurr < pEnd; c->rcurr++, c->rbytes--)
		{
			if(c->m_nRxCount == 0) // 0. 第 1 个字符 0x68
			{
				for(; c->rcurr < pEnd; c->rcurr++, c->rbytes--)
				{
					if((*c->rcurr) == 0x68)
					{
						c->m_pBuff[c->m_nRxCount++] = *c->rcurr; // First, 启动符	
#if 0						
						if(IsFixFrame())
						{
							m_nASDULen = m_nRxLen = 0; // 对于固定帧格式, ASDU和报文长度都置零
						}
#endif //#if 0						
						break;
					}
				}
			}
			else
			{
				if(0) //(IsFixFrame())
				{
					/**
				     * 短帧 格式, 只有 APCI 部分.
				     * 1. S帧 : 长度只有 6 个字节, 确认帧, 用于确认接收到的 I 帧 .
				     *			S帧的字节 1 固定为 01H，字节 2 固定为 00H，字节 3 和字节 4 为接收序号。
				     *
				     * 2. U帧 : 长度只有 6 个字节, 控制帧, 用于控制启动/ 停止/ 测试 .
				     *          U帧的字节2、3、4均固定为 00H，字节 1 包含 TESTFR，STARTDT
				     *			和 STOPDT 三种功能，同时只能激活其中的一种功能。
					 */ 
				}
				else
				{
					/**
				 	 * 长帧 格式	, 由 APCI 和 ASDU 两部分组成 => APDU
				 	 * 1. I帧 : 信息帧, 长度一定大于 6 个字节, 用于传输数据.
				 	 */
					if (c->m_nRxCount == 1)			/** 长度 */
					{
						c->m_pBuff[c->m_nRxCount++] = *c->rcurr;
						//printf("----len : %02x \r\n", c->m_pBuff[c->m_nRxCount-1]);
						if (*c->rcurr < (4+2)){
							c->m_nRxCount = 0;	// 总长度至少为 4+2 字节
						}else{
							c->m_nRxLen = *c->rcurr;
						}
					}else if(c->m_nRxCount > 1 && c->m_nRxCount <= 3)	/** 发送序号 / 控制域 1 */
					{

					}else if(c->m_nRxCount > 3 && c->m_nRxCount <= 5)	/** 接收序号 / 控制域 1 */
					{
						
					}
				}
			}

			if(c->m_bHaveNew)
			{
				break;
			}
		}
	}
	
//	if((unsigned char)c->rbuf[0] == (unsigned char)0x68){
//		printf("----len : %02x \r\n", c->rbuf[1]);
//	}
	
	/**
	 * 2018-08-26 
	 * 1. 暂且按 ascii_prot 处理 ,  目前 try_read_command() 暂时无实际意义, 对解析报文无影响.
	 * 2.  
	 */
	c->protocol = ascii_prot;	
	if(c->protocol == binary_prot) {
		//
	} else {
		char *el, *cont;
		if (0 == c->rbytes) { /** 读buffer 目前没有待解析的数据 */
			return 0;
		}
		el = memchr(c->rcurr, '\n', c->rbytes); //找第一个命令的末尾, 即换行符
		if (!el) {
			if(0) //(c->rbytes > 1024){
			{
				char *ptr = c->rcurr;
				while (*ptr == ' '){
					/* ignore leading whitespaces */
					++ptr;
				}

				if((ptr - c->rcurr) > 100 ||
					(strncmp(ptr, "get", 4) && strncmp(ptr, "gets", 5))){

					conn_set_state(c, conn_closing);
					return 1;
				}
			} // if(c->rbytes > 1024)

			/** 如果没有找到换行符，则说明读到的数据还不足以成为一个完整的命令,             返回0 */
			return 0;
		} // if (!el)
		
		cont = el + 1; //下一个命令的开头
		/**
         * 1. 下面这个if的作用是把el指向当前命令最后一个有效字符的下一个字符，即\r
         *   目的是为了在命令后面插上一个\0，字符串结束符。
         *	 例如 GET abc\r\n******，变成GET abc\0\n*****，这样以后读出的字符串就是一个命令。
         */
		if((el - c->rcurr) > 1 && *(el - 1) == '\r') {
			el--;
		}
		*el = '\0';

		assert(cont <= (c->rcurr + c->rbytes));

		//process_command(c, c->rcurr);
		
		/**
		 * 1. 当前命令执行完之后，把当前指针rcurr指向 下一个命令的开头，并调用rbytes（剩余未处理字节数大小）
		 *   逻辑上相当于把已处理的命令去掉。
		 */
        c->rbytes -= (cont - c->rcurr);
        c->rcurr = cont;

        assert(c->rcurr <= (c->rbuf + c->rsize));		
	}
	
	return 1;
}

